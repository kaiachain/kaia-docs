# ì˜¤ë¼í´ ë„¤íŠ¸ì›Œí¬

## ì†Œê°œ

![](/img/build/tools/klaytnXorakl.png)

[ì˜¤ë¼í´ ë„¤íŠ¸ì›Œí¬](https://docs.orakl.network/docs/developers-guide/readme)ëŠ” ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ê°€ ì˜¤í”„ì²´ì¸ ë°ì´í„° ë° ê¸°íƒ€ ë¦¬ì†ŒìŠ¤ì— ì•ˆì „í•˜ê²Œ ì ‘ê·¼í•  ìˆ˜ ìˆë„ë¡ í•˜ëŠ” íƒˆì¤‘ì•™í™” ì˜¤ë¼í´ ë„¤íŠ¸ì›Œí¬ì…ë‹ˆë‹¤. It prides itself in being a native token oracle that provides [Data Feed](https://docs.orakl.network/developers-guide/data-feed), [VRF](https://docs.orakl.network/developers-guide/vrf), [Request-Response](https://docs.orakl.network/developers-guide/request-response) and [Proof of Reserve](https://docs.orakl.network/developers-guide/proof-of-reserve) solutions.

ì˜¤ë¼í´ ë„¤íŠ¸ì›Œí¬ë¥¼ í†µí•´ ì‚¬ìš©ìëŠ” ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì—ì„œ ì˜ˆì¸¡ ë¶ˆê°€ëŠ¥í•˜ê³  í¸í–¥ë˜ì§€ ì•Šì€ ë¬´ì‘ìœ„ì„±ì„ í™•ë³´í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜¤ë¼í´ ë„¤íŠ¸ì›Œí¬ [ê²€ì¦ ê°€ëŠ¥í•œ ëœë¤ í•¨ìˆ˜(VRF)](https://docs.orakl.network/docs/developers-guide/verifiable-random-function-vrf#what-is-verifiable-random-function)ëŠ” ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ê°€ VRFë¥¼ ì‚¬ìš©í•˜ì—¬ ê²€ì¦ ê°€ëŠ¥í•œ ëœë¤ ê°’ì„ ìƒì„±í•  ìˆ˜ ìˆë„ë¡ í•˜ë©°, ì´ëŠ” ë¬´ì‘ìœ„ì„±ì´ í•„ìš”í•œ ë‹¤ì–‘í•œ dAppì—ì„œ ì‚¬ìš©ë  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì˜¤ë¼í´ ë„¤íŠ¸ì›Œí¬ëŠ” ê°œë°œìì—ê²Œ ë‘ ê°€ì§€ ê²°ì œ ë°©ë²•ì„ í†µí•´ VRF ì„œë¹„ìŠ¤ì— ëŒ€í•œ ì•¡ì„¸ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤: [Prepayment](https://docs.orakl.network/docs/developers-guide/readme#prepayment) ë˜ëŠ” [Direct Method](https://docs.orakl.network/docs/developers-guide/readme#direct-payment).

ì´ íŠœí† ë¦¬ì–¼ì—ì„œëŠ” ì˜¤ë¼í´ ë„¤íŠ¸ì›Œí¬ì˜ VRF ê¸°ëŠ¥ì„ í™œìš©í•˜ì—¬ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì—ì„œ ë‚œìˆ˜ë¥¼ ìš”ì²­í•©ë‹ˆë‹¤.

## ì „ì œ ì¡°ê±´

- [Kaikas](https://chrome.google.com/webstore/detail/kaikas/jblndlipeogpafnldhgmapagcccfchpi?hl=en)
- [Remix IDE](https://remix.ethereum.org/)
- [Remix í´ë ˆì´íŠ¼ í”ŒëŸ¬ê·¸ì¸](https://klaytn.foundation/using-klaytn-plugin-on-remix/)
- [Faucet](https://baobab.wallet.klaytn.foundation/faucet)ì—ì„œ í…ŒìŠ¤íŠ¸ KLAY ì–»ê¸°

## ì‹œì‘í•˜ê¸°

ë‹¤ìŒ ë‹¨ê³„ì—ì„œëŠ” ì˜¤ë¼í´ ë„¤íŠ¸ì›Œí¬ë¥¼ ì‚¬ìš©í•˜ì—¬ ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì—ì„œ ë‚œìˆ˜ë¥¼ ìš”ì²­í•©ë‹ˆë‹¤. ì´ì œ ì‹œì‘í•´ë³´ê² ìŠµë‹ˆë‹¤!

### 2ë‹¨ê³„: ì»¨íŠ¸ë™íŠ¸ ìƒíƒœ ë³€ìˆ˜ ì´ˆê¸°í™”

ì´ ë‹¨ê³„ì—ì„œëŠ” ì»¨íŠ¸ë™íŠ¸ ê¸°ëŠ¥ì— í•„ìš”í•œ ìƒíƒœ ë³€ìˆ˜ë¥¼ ì´ˆê¸°í™”í•©ë‹ˆë‹¤. Our consumer contract is dependent on `VRFConsumerBase` contract from which we inherit, and `IVRFCoordinator` interface that is used for calls to `VRFCoordinator` contract. Next, we define `sRandomWord` variable which we use to store the random word result and the `sOwner` variable which is used inside of `onlyOwner` modifier.

```solidity
pragma solidity ^0.8.16;

import { VRFConsumerBase } from "@bisonai/orakl-contracts/src/v0.1/VRFConsumerBase.sol";
import { IVRFCoordinator } from "@bisonai/orakl-contracts/src/v0.1/interfaces/IVRFCoordinator.sol";

contract VRFConsumer is VRFConsumerBase {
  uint256 public sRandomWord;
  address private sOwner;

  error OnlyOwner(address notOwner);
  modifier onlyOwner() {
      if (msg.sender != sOwner) {
          revert OnlyOwner(msg.sender);
      }
      _;
  }
```

### Step 2: Initialize VRF Coordinator

ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì—ì„œ ë‚œìˆ˜ ìš”ì²­ì„ í•˜ë ¤ë©´ [VRFCoordinator](https://github.com/Bisonai-CIC/orakl/blob/master/contracts/src/v0.1/VRFCoordinator.sol) ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ë¥¼ ì´ˆê¸°í™”í•´ì•¼ í•©ë‹ˆë‹¤. ìƒì„±ì íŒŒë¼ë¯¸í„°ë¥¼ í†µí•´ ì œê³µëœ VRFCoordinator ì£¼ì†Œì™€ VRFCoordinator ì¸í„°í˜ì´ìŠ¤ë¥¼ ë³¸ë”©í•˜ì—¬ ë‚œìˆ˜ ìš”ì²­(requestRandomWordsPayment)ì— ì‚¬ìš©í•˜ëŠ” ê²ƒì„ ê¶Œì¥í•©ë‹ˆë‹¤. The `VRFCoordinator` contract is deployed both on Klaytn Baobab [0xDA8c0A00A372503aa6EC80f9b29Cc97C454bE499](https://baobab.klaytnfinder.io/account/0xDA8c0A00A372503aa6EC80f9b29Cc97C454bE499) and Klaytn Cypress [0x3F247f70DC083A2907B8E76635986fd09AA80EFb](https://www.klaytnfinder.io/account/0x3F247f70DC083A2907B8E76635986fd09AA80EFb).

```solidity
  IVRFCoordinator COORDINATOR;

  constructor(address coordinator) VRFConsumerBase(coordinator) {
      COORDINATOR = IVRFCoordinator(coordinator);
      sOwner = msg.sender;
  }
```

### 3ë‹¨ê³„: ì§ì ‘ ê²°ì œë¡œ ë¬´ì‘ìœ„ ë‹¨ì–´ ìš”ì²­(ì†Œë¹„ì)

ì§ì ‘ ë©”ì„œë“œë¥¼ ì‚¬ìš©í•˜ì—¬ ë‚œìˆ˜ë¥¼ ìš”ì²­í•˜ë ¤ë©´ ì‚¬ìš©ìëŠ” value ì†ì„±ì„ ì‚¬ìš©í•˜ì—¬ í˜¸ì¶œê³¼ í•¨ê»˜ $KLAYë¥¼ ë³´ë‚´ì•¼ í•©ë‹ˆë‹¤.

```solidity
  function requestRandomWordsDirect(
      bytes32 keyHash,
      uint32 callbackGasLimit,
      uint32 numWords,
      address refundRecipient
  )
      public
      payable
      onlyOwner
      returns (uint256 requestId)
  {
    requestId = COORDINATOR.requestRandomWords{value: msg.value}(
      keyHash,
      callbackGasLimit,
      numWords,
      refundRecipient
    );
  }
```

ìœ„ ì½”ë“œëŠ” COORDINATOR ì»¨íŠ¸ë™íŠ¸ì— ì •ì˜ëœ `requestRandomWordsPayment()` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•˜ê³  í‚¤í•´ì‹œ, ì½œë°±ê°€ìŠ¤í•œë„, ëˆ”ì›Œì¦ˆë¥¼ ì¸ìë¡œ ì „ë‹¬í•˜ëŠ” í•¨ìˆ˜ì— ëŒ€í•´ ì„¤ëª…í•©ë‹ˆë‹¤. ì„œë¹„ìŠ¤ ëŒ€ê¸ˆì€ msg.valueë¥¼ í†µí•´ COORDINATOR ì»¨íŠ¸ë™íŠ¸ì˜ requestRandomWordsPayment()ë¡œ ì „ì†¡ë©ë‹ˆë‹¤. If the payment is larger than expected payment, exceeding payment is returned to the `refundRecipient` address. Eventually, it generates a request for random words. ê²°ì œ ê¸ˆì•¡ì´ ì˜ˆìƒ ê²°ì œ ê¸ˆì•¡ë³´ë‹¤ í´ ê²½ìš° ì´ˆê³¼ ê²°ì œ ê¸ˆì•¡ì€ requestRandomWordsPayment í•¨ìˆ˜ì˜ í˜¸ì¶œìì—ê²Œ ë°˜í™˜ë˜ë¯€ë¡œ ì‚¬ìš©ì ì»¨íŠ¸ë™íŠ¸ì—ì„œ ì½”ë“œ ìƒë‹¨ì— í‘œì‹œëœ ê²ƒì²˜ëŸ¼ [receive()](https://docs.soliditylang.org/en/v0.8.16/contracts.html#receive-ether-function) í•¨ìˆ˜ë¥¼ ì •ì˜í•´ì•¼ í•©ë‹ˆë‹¤.

### 4ë‹¨ê³„: ë¬´ì‘ìœ„ ë‹¨ì–´ ì±„ìš°ê¸°

ì´ í•¨ìˆ˜ëŠ” ë‚œìˆ˜ ìš”ì²­ì„ ì´í–‰í•  ë•Œ VRFCoordinator ì»¨íŠ¸ë™íŠ¸ì— ì˜í•´ í˜¸ì¶œë©ë‹ˆë‹¤.

```solidity
function fulfillRandomWords(
    uint256 /* requestId */,
    uint256[] memory randomWords
)
    internal
    override
{
    // requestId should be checked if it matches the expected request
    // Generate random value between 1 and 50.
    sRandomWord = (randomWords[0] % 50) + 1;
}
```

ì´ì œ ì˜¤ë¼í´ VRF ì†”ë£¨ì…˜ ì½”ë“œê°€ ìƒê²¼ìœ¼ë‹ˆ ì‹¤ì œë¡œ ì‘ë™í•˜ëŠ” ëª¨ìŠµì„ í™•ì¸í•´ ë³´ê² ìŠµë‹ˆë‹¤.

## ì‹¤ì œ êµ¬í˜„

In the example below, the contract allows us to request for random words and receive its fulfillment.

### ìƒ˜í”Œ ì½”ë“œ ìƒì„± ë° ë°°í¬

**Remix IDE**

- [Remix IDE](https://remix.ethereum.org/)ë¡œ ì´ë™í•©ë‹ˆë‹¤.
- íŒŒì¼ íƒìƒ‰ê¸° íƒ­ì„ í´ë¦­í•˜ê³  contracts í´ë”ì— demoOraklDirectVRF.solì´ë¼ëŠ” ìƒˆ íŒŒì¼ì„ ìƒì„±í•©ë‹ˆë‹¤.
- ìƒˆë¡œ ìƒì„±í•œ íŒŒì¼ì— ì•„ë˜ ì½”ë“œë¥¼ ë¶™ì—¬ë„£ìŠµë‹ˆë‹¤.
- Remixì—ì„œ **Compile contract**ì„ í´ë¦­í•©ë‹ˆë‹¤.
- í”ŒëŸ¬ê·¸ì¸ì„ ì„¤ì¹˜í•œ í›„ ì™¼ìª½ì˜ í´ë ˆì´íŠ¼ íƒ­ì„ í´ë¦­í•©ë‹ˆë‹¤.
- **Environment** > **Injected Caver** - **Kaikas**ë¥¼ ì„ íƒí•©ë‹ˆë‹¤.
- Contractì—ì„œ ì»¨íŠ¸ë™íŠ¸ë¥¼ ì„ íƒí•©ë‹ˆë‹¤. (ì˜ˆ: VRFConsumer)
- Pass in the coordinator contract address `0xDA8c0A00A372503aa6EC80f9b29Cc97C454bE499` (Baobab), `0x3F247f70DC083A2907B8E76635986fd09AA80EFb` (Cypress).
- **Deploy**ë¥¼ í´ë¦­í•©ë‹ˆë‹¤..

**ìƒ˜í”Œ ì½”ë“œ**

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.16;

import {VRFConsumerBase} from "@bisonai/orakl-contracts/src/v0.1/VRFConsumerBase.sol";
import {IVRFCoordinator} from "@bisonai/orakl-contracts/src/v0.1/interfaces/IVRFCoordinator.sol";

contract VRFConsumer is VRFConsumerBase {
    uint256 public sRandomWord;
    address private sOwner;

    IVRFCoordinator COORDINATOR;

    error OnlyOwner(address notOwner);

    modifier onlyOwner() {
        if (msg.sender != sOwner) {
            revert OnlyOwner(msg.sender);
        }
        _;
    }

    constructor(address coordinator) VRFConsumerBase(coordinator) {
        sOwner = msg.sender;
        COORDINATOR = IVRFCoordinator(coordinator);
    }

    function requestRandomWordsDirect(
        bytes32 keyHash,
        uint32 callbackGasLimit,
        uint32 numWords,
        address refundRecipient
    ) public payable onlyOwner returns (uint256 requestId) {
        requestId = COORDINATOR.requestRandomWords{value: msg.value}(
            keyHash,
            callbackGasLimit,
            numWords,
            refundRecipient
        );
    }

    function fulfillRandomWords(
        uint256 /* requestId */,
        uint256[] memory randomWords
    ) internal override {
        // requestId should be checked if it matches the expected request
        // Generate random value between 1 and 50.
        sRandomWord = (randomWords[0] % 50) + 1;
    }
}
```

![](/img/build/tools/orakl-vrf-deploy.png)

### ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì™€ì˜ ìƒí˜¸ì‘ìš©

ìŠ¤ë§ˆíŠ¸ ì»¨íŠ¸ë™íŠ¸ì—ì„œ ë‚œìˆ˜ë¥¼ ìš”ì²­í•˜ë ¤ë©´ ë¨¼ì € `requestRandomWordsDirect()` í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•´ì•¼ í•©ë‹ˆë‹¤. ì´ í•¨ìˆ˜ê°€ ì„±ê³µì ìœ¼ë¡œ ì‹¤í–‰ë˜ë ¤ë©´ ì•ì„œ ì„¤ëª…í•œ ëŒ€ë¡œ ì‚¬ìš©ìê°€ KLAY(ìµœì†Œ 1 KLAY)ë¥¼ ë³´ë‚´ì•¼ í•©ë‹ˆë‹¤. `keyHash` parameter uniquely defines who can fulfill the request. Orakl Network VRF provides one key hash for each Klaytn chain:

- Kairos: `0xd9af33106d664a53cb9946df5cd81a30695f5b72224ee64e798b278af812779c`
- Mainnet: `0x6cff5233743b3c0321a19ae11ab38ae0ddc7ddfe1e91b162fa8bb657488fb157`

For the rest of the parameters, you can set them as follows:

- `callbackGasLimit` as `500000`,
- `numWords` as `1`, and
- set `refundRecipient` to your EOA address.

ì´í›„ ìš”ì²­ì´ ì™„ë£Œë˜ë©´ `s_randomResult()` í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ s_randomResult() í•¨ìˆ˜ëŠ” ë‚œìˆ˜ë¥¼ ë°˜í™˜í•©ë‹ˆë‹¤.

- **requestRandomWordsDirect()**: ì´ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ê¸° ìœ„í•´ 1 KLAYë¥¼ ì „ì†¡í•©ë‹ˆë‹¤. ì•„ë˜ ì´ë¯¸ì§€ê°€ ì´ë¥¼ ì„¤ëª…í•©ë‹ˆë‹¤:

![](/img/build/tools/orakl-vrf-request.png)

- **s_randomResult()**: VRFCoordinatorê°€ ë‚œìˆ˜ ìš”ì²­ì„ ìˆ˜í–‰í•œ í›„ ì‘ë‹µì€ s_randomResult ë³€ìˆ˜ì— ì €ì¥ë©ë‹ˆë‹¤. ì‘ë‹µì„ ì–»ìœ¼ë ¤ë©´ `s_response()` í•¨ìˆ˜ë¥¼ í˜¸ì¶œí•©ë‹ˆë‹¤.

![](/img/build/tools/orakl-vrf-response.png)

Tada ğŸ‰! You just requested for a random word and received one in your smart contract.

## ê²°ë¡ 

ì´ íŠœí† ë¦¬ì–¼ì—ì„œëŠ” ì˜¤ë¼í´ ë„¤íŠ¸ì›Œí¬ VRF ì†”ë£¨ì…˜ì„ ì‚¬ìš©í•˜ì—¬ ìŠ¤ë§ˆíŠ¸ ì½˜íŠ¸ë™íŠ¸ì—ì„œ ë‚œìˆ˜ë¥¼ ìƒì„±í•˜ëŠ” ë°©ë²•ì„ ë°°ì› ìŠµë‹ˆë‹¤. ì˜¤ë¼í´ ë„¤íŠ¸ì›Œí¬ëŠ” ê°€ê²© í”¼ë“œ, ë°ì´í„° ìš”ì²­-ì‘ë‹µ ë“±ê³¼ ê°™ì€ ë” ë§ì€ ì˜¤ë¼í´ ì„œë¹„ìŠ¤ë¥¼ ì œê³µí•©ë‹ˆë‹¤. ì˜¤ë¼í´ ë„¤íŠ¸ì›Œí¬ì™€ ì‘ë™ ë°©ì‹ì— ëŒ€í•œ ìì„¸í•œ ê°€ì´ë“œëŠ” [ì˜¤ë¼í´ ë„¤íŠ¸ì›Œí¬ ë¬¸ì„œ](https://docs.orakl.network/docs/developers-guide/readme)ë¥¼ ì°¸ê³ í•˜ì‹œê¸° ë°”ëë‹ˆë‹¤.
